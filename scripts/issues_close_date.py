#!/usr/bin/env python3
"""
Script para gerenciar o campo "Data Fim" em projetos GitHub.

Este script verifica issues em reposit√≥rios e gerencia o campo "Data Fim" 
nos projetos especificados baseado no status do issue.

Regras de neg√≥cio:
- Se status != "Done": campo "Data Fim" deve estar vazio
- Se status == "Done" e issue fechado e campo vazio: preencher com data de fechamento do issue
- Se status == "Done" e campo preenchido: manter como est√°
- Se status == "Done" mas issue n√£o fechado: n√£o preencher campo

Environment variables used:
- GITHUB_TOKEN: GitHub token with write access to Projects v2
- GITHUB_ORG: Organization login (default: splor-mg)

Usage:
  python scripts/issues_close_date.py                                    # Usa projeto do .env ou padr√£o hardcoded
  python scripts/issues_close_date.py --panel                            # Sele√ß√£o interativa de projetos
  python scripts/issues_close_date.py --projects "1,2,3"                 # Projetos espec√≠ficos via argumento
  python scripts/issues_close_date.py --org "minha-org" --verbose        # Organiza√ß√£o diferente

Ordem de prioridade para projeto padr√£o:
  1. Argumento --projects (maior prioridade)
  2. Vari√°vel GITHUB_PROJECT_PANEL_DEFAULT no arquivo .env
  3. Valor hardcoded DEFAULT_PROJECT_PANEL (menor prioridade)
"""

from __future__ import annotations

import argparse
import csv
import datetime as dt
import json
import os
import sys
import time
from pathlib import Path
from typing import Any, Dict, List, Optional

import requests
import yaml

# Configura√ß√µes padr√£o
DEFAULT_ORG = 'splor-mg'
DEFAULT_REPOS_FILE = 'docs/repos_list.csv'
DEFAULT_PROJECTS_LIST = 'docs/projects-panels-list.yml'
DEFAULT_PROJECT_PANEL = 13  # N√∫mero do projeto "Gest√£o √† Vista AID"
DEFAULT_FIELD_NAME = 'Data Fim'

GITHUB_GRAPHQL_URL = "https://api.github.com/graphql"

def load_dotenv():
    """Carrega vari√°veis de ambiente do arquivo .env"""
    env_file = Path('.env')
    if env_file.exists():
        print(f"üìÅ Carregando vari√°veis de {env_file}...")
        with open(env_file, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    os.environ[key] = value
        print("‚úÖ Vari√°veis de ambiente carregadas")
    else:
        print(f"‚ö†Ô∏è  Arquivo {env_file} n√£o encontrado")


def update_projects_data():
    """Chama o script projects_panels.py para atualizar os arquivos de projetos"""
    import subprocess
    import sys
    
    print("üîÑ Atualizando dados dos projetos...")
    
    try:
        # Executar o script projects_panels.py
        result = subprocess.run([
            sys.executable, 'scripts/projects_panels.py'
        ], capture_output=True, text=True, cwd=Path.cwd())
        
        if result.returncode == 0:
            print("‚úÖ Dados dos projetos atualizados com sucesso")
            if result.stdout:
                print(f"üìã Sa√≠da do projects_panels.py: {result.stdout}")
            return True
        else:
            print(f"‚ùå Erro ao atualizar dados dos projetos: {result.stderr}")
            if result.stdout:
                print(f"üìã Sa√≠da do projects_panels.py: {result.stdout}")
            return False
    except Exception as e:
        print(f"‚ùå Erro ao executar projects_panels.py: {e}")
        return False

def _require_env(name: str) -> str:
    """Get required environment variable or raise error."""
    value = os.getenv(name)
    if not value:
        raise RuntimeError(f"Missing required environment variable: {name}")
    return value

def _graphql(token: str, query: str, variables: Dict[str, Any]) -> Dict[str, Any]:
    """Execute GraphQL query against GitHub API."""
    headers = {
        "Authorization": f"Bearer {token}",
        "Accept": "application/vnd.github+json",
    }
    resp = requests.post(
        GITHUB_GRAPHQL_URL, 
        json={"query": query, "variables": variables}, 
        headers=headers
    )
    if resp.status_code != 200:
        raise RuntimeError(f"GraphQL HTTP {resp.status_code}: {resp.text}")
    data = resp.json()
    if "errors" in data:
        raise RuntimeError(f"GraphQL errors: {json.dumps(data['errors'], ensure_ascii=False)}")
    return data["data"]

def _iso_date(date_str: str) -> str:
    """Return YYYY-MM-DD from an ISO datetime string."""
    try:
        # GitHub gives ISO 8601 like 2025-08-27T23:59:59Z
        d = dt.datetime.fromisoformat(date_str.replace("Z", "+00:00"))
        return d.date().isoformat()
    except Exception:
        # If already a date, return as-is
        return date_str[:10]

def load_repos_from_csv(csv_file: str) -> List[Dict[str, Any]]:
    """Carrega a lista de reposit√≥rios do arquivo CSV"""
    repos = []
    
    if not os.path.exists(csv_file):
        print(f"‚ùå Arquivo {csv_file} n√£o encontrado!")
        print("üí° Execute primeiro o script repos_list.py para gerar a lista")
        return repos
    
    print(f"üìã Carregando reposit√≥rios de {csv_file}...")
    
    with open(csv_file, 'r', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            repos.append({
                'name': row['name'], 
                'archived': row.get('archived', 'False') == 'True'
            })
    
    print(f"‚úÖ {len(repos)} reposit√≥rios carregados")
    return repos

def load_projects_from_yaml(yaml_file: str) -> List[Dict[str, Any]]:
    """Carrega a lista de projetos do arquivo YAML"""
    projects = []
    
    if not os.path.exists(yaml_file):
        print(f"‚ùå Arquivo {yaml_file} n√£o encontrado!")
        return projects
    
    print(f"üìä Carregando projetos de {yaml_file}...")
    
    try:
        with open(yaml_file, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f)
            if data and 'projects' in data:
                projects = data['projects']
                print(f"‚úÖ {len(projects)} projetos carregados")
            else:
                print("‚ö†Ô∏è  Nenhum projeto encontrado no arquivo YAML")
    except yaml.YAMLError as e:
        print(f"‚ùå Erro ao ler arquivo YAML: {e}")
    
    return projects


def select_panels_interactive(projects_list: List[Dict[str, Any]], field_name: str = DEFAULT_FIELD_NAME) -> List[int]:
    """Interface interativa para sele√ß√£o de pain√©is"""
    if not projects_list:
        print("‚ùå Nenhum projeto dispon√≠vel para sele√ß√£o")
        return []
    
    # Criar dicion√°rio para busca r√°pida por n√∫mero do projeto
    projects_by_number = {project['number']: project for project in projects_list}
    available_numbers = sorted(projects_by_number.keys())
    
    print("\nüìã Projetos dispon√≠veis:")
    print("=" * 60)
    
    for project_number in available_numbers:
        project = projects_by_number[project_number]
        print(f"num. prj: {project_number}")
        print(f"    name: {project['name']}")
        print(f"      ID: {project['id']}")
        print()
    
    print("=" * 60)
    
    while True:
        try:
            selection = input("Digite o(s) n√∫mero(s) do(s) projeto(s) que deseja sincronizar (separados por v√≠rgula) ou 'all' para todos: ").strip()
            
            if selection.lower() == 'all':
                selected_projects = []
                for project_number in available_numbers:
                    project = projects_by_number[project_number]
                    # Verificar se o projeto possui o campo especificado
                    has_field = False
                    for field in project.get('fields', []):
                        if field.get('name', '').strip().lower() == field_name.strip().lower():
                            has_field = True
                            break
                    
                    if has_field:
                        selected_projects.append(project_number)
                        print(f"  ‚úÖ Projeto '{project['name']}' (#{project_number}) possui campo '{field_name}'")
                    else:
                        print(f"  ‚ùå Projeto '{project['name']}' (#{project_number}) N√ÉO possui campo '{field_name}'")
                
                if not selected_projects:
                    print(f"\n‚ùå Nenhum dos projetos selecionados possui o campo '{field_name}'")
                    print("üí° Verifique se o campo existe nos projetos ou use um nome de campo diferente")
                    return []
                
                print(f"\n‚úÖ Projetos selecionados: {selected_projects}")
                return selected_projects
            
            # Parse da sele√ß√£o
            numbers = [int(x.strip()) for x in selection.split(',')]
            
            # Validar n√∫meros e verificar campos
            valid_numbers = []
            selected_project_names = []
            
            for num in numbers:
                if num in projects_by_number:
                    project = projects_by_number[num]
                    project_name = project['name']
                    
                    # Verificar se o projeto possui o campo especificado
                    has_field = False
                    for field in project.get('fields', []):
                        if field.get('name', '').strip().lower() == field_name.strip().lower():
                            has_field = True
                            break
                    
                    if has_field:
                        valid_numbers.append(num)
                        selected_project_names.append(project_name)
                    else:
                        print(f"‚ùå Projeto '{project_name}' (#{num}) N√ÉO possui o campo '{field_name}'")
                        print(f"üí° O processo ser√° interrompido pois o projeto selecionado n√£o tem o campo pretendido")
                        return []
                else:
                    print(f"‚ùå N√∫mero inv√°lido: {num}. Use n√∫meros de projeto v√°lidos: {', '.join(map(str, available_numbers))}")
                    break
            else:
                if valid_numbers:
                    print(f"‚úÖ Projetos selecionados: {valid_numbers}")
                    for number, name in zip(valid_numbers, selected_project_names):
                        print(f"Projeto selecionado: {number} - {name}")
                    return valid_numbers
                else:
                    print("‚ùå Nenhum projeto v√°lido selecionado")
                    continue
                    
        except ValueError:
            print("‚ùå Formato inv√°lido. Use n√∫meros separados por v√≠rgula (ex: 1,3,5) ou 'all'")
        except KeyboardInterrupt:
            print("\n‚èπÔ∏è  Opera√ß√£o cancelada pelo usu√°rio")
            return []

def filter_projects_by_numbers(projects_list: List[Dict[str, Any]], target_numbers: List[int]) -> List[Dict[str, Any]]:
    """Filtra projetos da lista pelos n√∫meros especificados"""
    filtered_projects = []
    
    for project in projects_list:
        if project.get('number') in target_numbers:
            filtered_projects.append(project)
            print(f"  ‚úÖ Projeto '{project['name']}' (#{project['number']}) selecionado")
    
    return filtered_projects


def load_projects_with_fields_from_yaml(yaml_file: str, target_numbers: List[int], field_name: str = DEFAULT_FIELD_NAME) -> List[Dict[str, Any]]:
    """Carrega projetos completos do arquivo YAML e filtra pelos n√∫meros e campo especificados"""
    projects = []
    
    if not os.path.exists(yaml_file):
        print(f"‚ùå Arquivo {yaml_file} n√£o encontrado!")
        return projects
    
    print(f"üìä Carregando projetos completos de {yaml_file}...")
    
    try:
        with open(yaml_file, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f)
            if data and 'projects' in data:
                all_projects = data['projects']
                print(f"üîç Total de projetos no arquivo: {len(all_projects)}")
                print(f"üéØ N√∫meros de projeto solicitados: {target_numbers}")
                print(f"üîç Campo procurado: '{field_name}'")
                
                # Filtrar pelos n√∫meros especificados
                for project in all_projects:
                    if project.get('number') in target_numbers:
                        print(f"üîç Analisando projeto: {project['name']} (#{project['number']})")
                        print(f"   Campos dispon√≠veis: {[f.get('name', 'N/A') for f in project.get('fields', [])]}")
                        
                        # Verificar se possui o campo especificado
                        has_field = False
                        for field in project.get('fields', []):
                            field_name_actual = field.get('name', '').strip()
                            if field_name_actual.lower() == field_name.strip().lower():
                                has_field = True
                                print(f"   ‚úÖ Campo encontrado: '{field_name_actual}' (exato)")
                                break
                        
                        if has_field:
                            projects.append(project)
                            print(f"  ‚úÖ Projeto '{project['name']}' (#{project['number']}) possui campo '{field_name}'")
                        else:
                            print(f"  ‚è≠Ô∏è  Projeto '{project['name']}' (#{project['number']}) n√£o possui campo '{field_name}'")
                
                print(f"‚úÖ {len(projects)} projetos carregados e filtrados")
            else:
                print("‚ö†Ô∏è  Nenhum projeto encontrado no arquivo YAML")
    except yaml.YAMLError as e:
        print(f"‚ùå Erro ao ler arquivo YAML: {e}")
    
    return projects

def get_project_field_id(project: Dict[str, Any], field_name: str = DEFAULT_FIELD_NAME) -> Optional[str]:
    """Obt√©m o ID do campo especificado no projeto"""
    for field in project.get('fields', []):
        if field.get('name', '').strip().lower() == field_name.strip().lower():
            return field['id']
    return None

def get_issues_from_repo(token: str, org: str, repo_name: str, target_projects: List[Dict[str, Any]] = None, days_filter: int = 7) -> List[Dict[str, Any]]:
    """Obt√©m issues de um reposit√≥rio com filtros inteligentes baseados em Status do projeto e data"""
    
    # Filtro inteligente 1: Buscar apenas issues que est√£o em projetos alvo
    project_filter = ""
    if target_projects:
        project_ids = [project['id'] for project in target_projects]
        project_filter = f', projectItems: {{first: 50, projectIds: {json.dumps(project_ids)}}}'
    
    # Filtro inteligente 2: Filtro por data (se days_filter > 0)
    date_filter = ""
    if days_filter > 0:
        from datetime import datetime, timedelta
        cutoff_date = (datetime.now() - timedelta(days=days_filter)).isoformat()
        date_filter = f', filterBy: {{since: "{cutoff_date}"}}'
    
    query = f"""
    query($owner: String!, $repo: String!, $cursor: String) {{
      repository(owner: $owner, name: $repo) {{
        issues(first: 100, after: $cursor, states: [OPEN, CLOSED], orderBy: {{field: UPDATED_AT, direction: DESC}}{date_filter}) {{
          nodes {{
            id
            number
            title
            state
            closedAt
            updatedAt
            createdAt
            projectItems(first: 50) {{
              nodes {{
                id
                project {{
                  id
                  number
                  title
                }}
                fieldValues(first: 50) {{
                  nodes {{
                    ... on ProjectV2ItemFieldSingleSelectValue {{
                      field {{
                        ... on ProjectV2FieldCommon {{
                          name
                        }}
                      }}
                      name
                    }}
                    ... on ProjectV2ItemFieldDateValue {{
                      field {{
                        ... on ProjectV2FieldCommon {{
                          name
                        }}
                      }}
                      date
                    }}
                  }}
                }}
              }}
            }}
          }}
          pageInfo {{
            hasNextPage
            endCursor
          }}
        }}
      }}
    }}
    """
    
    all_issues = []
    cursor = None
    
    while True:
        variables = {"owner": org, "repo": repo_name, "cursor": cursor}
        data = _graphql(token, query, variables)
        
        repository = data.get("repository")
        if not repository:
            break
            
        issues = repository.get("issues", {}).get("nodes", [])
        all_issues.extend(issues)
        
        page_info = repository.get("issues", {}).get("pageInfo", {})
        if not page_info.get("hasNextPage"):
            break
            
        cursor = page_info.get("endCursor")
    
    return all_issues

def has_relevant_issues(token: str, org: str, repo_name: str, target_projects: List[Dict[str, Any]], days_filter: int = 7) -> bool:
    """Verifica se o reposit√≥rio tem issues em projetos alvo antes de processar tudo"""
    if not target_projects:
        return True  # Se n√£o h√° projetos alvo, processa tudo
    
    project_ids = [project['id'] for project in target_projects]
    
    # Filtro por data (se days_filter > 0)
    date_filter = ""
    if days_filter > 0:
        from datetime import datetime, timedelta
        cutoff_date = (datetime.now() - timedelta(days=days_filter)).isoformat()
        date_filter = f', filterBy: {{since: "{cutoff_date}"}}'
    
    # Query otimizada para verificar apenas se existem issues em projetos
    query = f"""
    query($owner: String!, $repo: String!) {{
      repository(owner: $owner, name: $repo) {{
        issues(first: 1, states: [OPEN, CLOSED]{date_filter}) {{
          nodes {{
            projectItems(first: 1) {{
              nodes {{
                project {{
                  id
                }}
              }}
            }}
          }}
        }}
      }}
    }}
    """
    
    try:
        data = _graphql(token, query, {"owner": org, "repo": repo_name})
        repository = data.get("repository")
        if not repository:
            return False
            
        issues = repository.get("issues", {}).get("nodes", [])
        
        # Verificar se algum issue est√° em algum projeto alvo
        for issue in issues:
            for project_item in issue.get("projectItems", {}).get("nodes", []):
                project_id = project_item.get("project", {}).get("id")
                if project_id in project_ids:
                    return True
        
        return False
    except Exception as e:
        print(f"      ‚ö†Ô∏è  Erro ao verificar issues relevantes: {e}")
        return True  # Em caso de erro, processa para n√£o perder dados

def filter_issues_that_need_processing(issues: List[Dict[str, Any]], target_projects: List[Dict[str, Any]], field_name: str = DEFAULT_FIELD_NAME) -> List[Dict[str, Any]]:
    """Filtra issues que precisam de processamento baseado no Status do projeto:
    - Status != 'Done' e campo preenchido: precisa limpar campo
    - Status = 'Done' e issue fechado e campo vazio: precisa preencher campo
    """
    filtered_issues = []
    target_project_ids = {project['id'] for project in target_projects}
    
    for issue in issues:
        issue_needs_processing = False
        
        # Verificar se o issue est√° em algum projeto alvo
        for project_item in issue.get('projectItems', {}).get('nodes', []):
            project_id = project_item.get('project', {}).get('id')
            if project_id not in target_project_ids:
                continue
            
            # Verificar se precisa de altera√ß√£o baseado nas regras de neg√≥cio
            status, current_date = get_project_item_status_and_date(project_item, field_name)
            issue_state = issue.get('state')
            issue_closed_at = issue.get('closedAt')
            
            if status and status.lower() != 'done':
                # Status != "Done": campo deve estar vazio
                if current_date:
                    issue_needs_processing = True
                    break
            elif status and status.lower() == 'done':
                # Status == "Done": campo deve ter data de fechamento
                if not current_date and issue_closed_at and issue_state == 'CLOSED':
                    issue_needs_processing = True
                    break
        
        if issue_needs_processing:
            filtered_issues.append(issue)
    
    return filtered_issues

def get_project_item_status_and_date(project_item: Dict[str, Any], field_name: str = DEFAULT_FIELD_NAME) -> tuple[Optional[str], Optional[str]]:
    """Obt√©m o status e a data do campo especificado do item do projeto"""
    status = None
    date_value = None
    
    for field_value in project_item.get('fieldValues', {}).get('nodes', []):
        field = field_value.get('field', {})
        field_name_actual = field.get('name', '')
        
        if field_name_actual.strip().lower() == 'status':
            status = field_value.get('name')
        elif field_name_actual.strip().lower() == field_name.strip().lower():
            date_value = field_value.get('date')
    
    return status, date_value

def clear_date_field(token: str, project_id: str, item_id: str, field_id: str) -> bool:
    """Limpa o campo de data (define como null)"""
    mutation = """
    mutation($project: ID!, $item: ID!, $field: ID!) {
      updateProjectV2ItemFieldValue(
        input: {
          projectId: $project,
          itemId: $item,
          fieldId: $field,
          value: { date: null }
        }
      ) { clientMutationId }
    }
    """
    
    try:
        _graphql(token, mutation, {"project": project_id, "item": item_id, "field": field_id})
        return True
    except Exception as e:
        print(f"      ‚ùå Erro ao limpar campo: {e}")
        return False

def set_date_field(token: str, project_id: str, item_id: str, field_id: str, date_value: str) -> bool:
    """Define o campo de data com o valor especificado"""
    mutation = """
    mutation($project: ID!, $item: ID!, $field: ID!, $value: Date!) {
      updateProjectV2ItemFieldValue(
        input: {
          projectId: $project,
          itemId: $item,
          fieldId: $field,
          value: { date: $value }
        }
      ) { clientMutationId }
    }
    """
    
    try:
        _graphql(token, mutation, {
            "project": project_id, 
            "item": item_id, 
            "field": field_id, 
            "value": date_value
        })
        return True
    except Exception as e:
        print(f"      ‚ùå Erro ao definir campo: {e}")
        return False

def process_issue_for_projects(token: str, issue: Dict[str, Any], target_projects: List[Dict[str, Any]], 
                              field_name: str = DEFAULT_FIELD_NAME) -> Dict[str, int]:
    """Processa um issue para todos os projetos alvo"""
    changes = {"cleared": 0, "set": 0, "errors": 0}
    
    issue_number = issue.get('number')
    issue_title = issue.get('title', '')
    issue_state = issue.get('state')
    issue_closed_at = issue.get('closedAt')
    
    print(f"  üîç Processando issue #{issue_number}: {issue_title[:50]}...")
    
    # Para cada item do projeto associado ao issue
    for project_item in issue.get('projectItems', {}).get('nodes', []):
        project = project_item.get('project', {})
        project_id = project.get('id')
        project_number = project.get('number')
        project_title = project.get('title', '')
        
        # Verificar se este projeto est√° na lista de projetos alvo
        target_project = None
        for tp in target_projects:
            if tp.get('id') == project_id:
                target_project = tp
                break
        
        if not target_project:
            continue
        
        print(f"    üìã Projeto: {project_title} (#{project_number})")
        
        # Obter ID do campo "Data Fim"
        field_id = get_project_field_id(target_project, field_name)
        if not field_id:
            print(f"      ‚ö†Ô∏è  Campo '{field_name}' n√£o encontrado no projeto")
            continue
        
        # Obter status e valor atual do campo
        status, current_date = get_project_item_status_and_date(project_item, field_name)
        
        print(f"      üìä Status: {status}, Data atual: {current_date or 'vazio'}")
        
        # Aplicar regras de neg√≥cio
        if status and status.lower() != 'done':
            # Status != "Done": campo deve estar vazio
            if current_date:
                print(f"      üóëÔ∏è  Limpando campo '{field_name}' (status != Done)")
                if clear_date_field(token, project_id, project_item['id'], field_id):
                    changes["cleared"] += 1
                    print(f"      ‚úÖ Campo '{field_name}' limpo com sucesso")
                else:
                    changes["errors"] += 1
            else:
                print(f"      ‚úÖ Campo '{field_name}' j√° est√° vazio")
        
        elif status and status.lower() == 'done':
            # Status == "Done": campo deve ter data de fechamento
            if not current_date and issue_closed_at and issue_state == 'CLOSED':
                date_value = _iso_date(issue_closed_at)
                print(f"      üìÖ Definindo campo '{field_name}' para {date_value} (status = Done, issue fechado)")
                if set_date_field(token, project_id, project_item['id'], field_id, date_value):
                    changes["set"] += 1
                    print(f"      ‚úÖ Campo '{field_name}' definido para {date_value}")
                else:
                    changes["errors"] += 1
            elif current_date:
                print(f"      ‚úÖ Campo '{field_name}' j√° est√° preenchido: {current_date}")
            elif issue_state != 'CLOSED':
                print(f"      ‚ö†Ô∏è  Issue com status 'Done' mas n√£o est√° fechado (state: {issue_state})")
            else:
                print(f"      ‚ö†Ô∏è  Issue fechado mas sem data de fechamento")
    
    return changes

def parse_arguments():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(
        description="Gerencia o campo 'Data Fim' em projetos GitHub",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Exemplos de uso:
  python scripts/issues_close_date.py                               # Usa projeto do .env, √∫ltimos 7 dias (padr√£o)
  python scripts/issues_close_date.py --days 30                     # Processa issues dos √∫ltimos 30 dias
  python scripts/issues_close_date.py --all-issues                  # Processa TODOS os issues (primeira execu√ß√£o)
  python scripts/issues_close_date.py --panel                       # Sele√ß√£o interativa de projetos
  python scripts/issues_close_date.py --projects "1,2,3"            # Processa apenas projetos espec√≠ficos (n√∫meros)
  python scripts/issues_close_date.py --org "minha-org"             # Usa organiza√ß√£o diferente
  python scripts/issues_close_date.py --field "Data Conclus√£o"      # Usa nome de campo diferente
  python scripts/issues_close_date.py --verbose                     # Modo verboso com mais detalhes

Ordem de prioridade para projeto padr√£o:
  1. Argumento --projects (maior prioridade)
  2. Vari√°vel GITHUB_PROJECT_PANEL_DEFAULT no arquivo .env
  3. Valor hardcoded DEFAULT_PROJECT_PANEL (menor prioridade)
        """
    )
    
    parser.add_argument('--panel', 
                       action='store_true',
                       help='Sele√ß√£o interativa de projetos')
    parser.add_argument('--projects', 
                       help='Projetos espec√≠ficos (n√∫meros separados por v√≠rgula)')
    parser.add_argument('--org', 
                       help='Organiza√ß√£o para processar (padr√£o: splor-mg)')
    parser.add_argument('--field', 
                       default=DEFAULT_FIELD_NAME,
                       help=f'Nome do campo de data (padr√£o: {DEFAULT_FIELD_NAME})')
    parser.add_argument('--repos-file', 
                       default=DEFAULT_REPOS_FILE,
                       help=f'Arquivo CSV com lista de reposit√≥rios (padr√£o: {DEFAULT_REPOS_FILE})')
    parser.add_argument('--projects-list', 
                       default=DEFAULT_PROJECTS_LIST,
                       help=f'Arquivo YAML com lista de projetos (padr√£o: {DEFAULT_PROJECTS_LIST})')
    parser.add_argument('--verbose', '-v', 
                       action='store_true',
                       help='Modo verboso com mais detalhes')
    parser.add_argument('--days', 
                       type=int,
                       default=7,
                       help='Processar issues criados/modificados nos √∫ltimos N dias (padr√£o: 7, use 0 para todos)')
    parser.add_argument('--all-issues', 
                       action='store_true',
                       help='Processar TODOS os issues (sem filtro de data) - equivalente a --days 0')
    
    return parser.parse_args()

def main():
    """Fun√ß√£o principal"""
    args = parse_arguments()
    
    # Carregar vari√°veis de ambiente
    load_dotenv()
    
    # Obter token do GitHub
    github_token = os.getenv('GITHUB_TOKEN')
    
    if not github_token:
        print("‚ùå GITHUB_TOKEN n√£o encontrado!")
        print("üí° Certifique-se de que o arquivo .env cont√©m: GITHUB_TOKEN=seu_token_aqui")
        return

    print(f"üîë Usando token: {github_token[:8]}...")
    
    # Atualizar dados dos projetos primeiro
    if not update_projects_data():
        print("‚ö†Ô∏è  Continuando com dados existentes...")
    
    # Aplicar hierarquia de prioriza√ß√£o (argumentos > env vars > padr√µes)
    org = args.org or os.getenv("GITHUB_ORG") or DEFAULT_ORG
    
    # Processar argumentos de filtro de data
    days_filter = 0 if args.all_issues else args.days
    
    # Mostrar configura√ß√µes aplicadas
    print(f"\nüîß Configura√ß√µes aplicadas:")
    print(f"   Organiza√ß√£o: {org}")
    print(f"   Arquivo de reposit√≥rios: {args.repos_file}")
    print(f"   Arquivo de projetos: {args.projects_list}")
    print(f"   Campo: {args.field}")
    
    # Mostrar filtro de data aplicado
    if args.all_issues:
        print(f"   Filtro de data: TODOS os issues (--all-issues)")
    elif days_filter == 0:
        print(f"   Filtro de data: TODOS os issues (--days 0)")
    else:
        print(f"   Filtro de data: √∫ltimos {days_filter} dias (--days {days_filter})")
    
    # Mostrar qual valor foi aplicado e de onde veio
    if args.org:
        org_source = "argumento --org"
    elif os.getenv("GITHUB_ORG"):
        org_source = f"arquivo .env (GITHUB_ORG={os.getenv('GITHUB_ORG')})"
    else:
        org_source = f"valor padr√£o hardcoded (DEFAULT_ORG={DEFAULT_ORG})"
    
    print(f"   Fonte da organiza√ß√£o: {org_source}")
    
    if args.verbose:
        print(f"   Modo verboso ativado")
    
    try:
        # Carregar reposit√≥rios
        repos = load_repos_from_csv(args.repos_file)
        if not repos:
            print("‚ùå Nenhum reposit√≥rio encontrado para processar")
            return
        
        # Carregar lista de projetos (usar projects-panels.yml que tem os campos completos)
        projects_list = load_projects_from_yaml('docs/projects-panels.yml')
        if not projects_list:
            print("‚ùå Nenhum projeto encontrado na lista")
            return
        
        # Determinar quais projetos processar
        target_project_numbers = []
        
        if args.panel:
            # Sele√ß√£o interativa
            target_project_numbers = select_panels_interactive(projects_list, args.field)
            if not target_project_numbers:
                print("‚ùå Nenhum projeto selecionado")
                return
        elif args.projects:
            # Projetos espec√≠ficos via argumento
            try:
                target_project_numbers = [int(p.strip()) for p in args.projects.split(',')]
                print(f"üéØ Projetos especificados via argumento: {target_project_numbers}")
            except ValueError:
                print("‚ùå Formato inv√°lido para --projects. Use n√∫meros separados por v√≠rgula")
                return
        else:
            # Seguir ordem de prioridade: .env > hardcoded
            env_panel = os.getenv("GITHUB_PROJECT_PANEL_DEFAULT")
            if env_panel:
                try:
                    target_project_numbers = [int(env_panel)]
                    print(f"üéØ Usando projeto do arquivo .env: {target_project_numbers}")
                except (ValueError, TypeError):
                    print(f"‚ùå Valor inv√°lido para projeto no .env: {env_panel}")
                    return
            else:
                # Usar valor hardcoded como fallback
                try:
                    target_project_numbers = [int(DEFAULT_PROJECT_PANEL)]
                    print(f"üéØ Usando projeto padr√£o hardcoded: {target_project_numbers}")
                except (ValueError, TypeError):
                    print(f"‚ùå Valor inv√°lido para projeto padr√£o: {DEFAULT_PROJECT_PANEL}")
                    return
        
        # Carregar projetos completos com campos e filtrar
        print(f"\nüîç Carregando projetos completos e filtrando...")
        projects_with_field = load_projects_with_fields_from_yaml(
            'docs/projects-panels.yml', target_project_numbers, args.field
        )
        
        if not projects_with_field:
            print(f"‚ùå Nenhum projeto encontrado com campo '{args.field}' nos n√∫meros especificados")
            return
        
        print(f"‚úÖ {len(projects_with_field)} projetos ser√£o processados")
        
        # Processar cada reposit√≥rio
        total_changes = {"cleared": 0, "set": 0, "errors": 0}
        optimization_stats = {
            "repos_skipped_no_relevant_issues": 0,
            "repos_skipped_no_changes_needed": 0,
            "total_issues_found": 0,
            "total_issues_processed": 0
        }
        
        for i, repo in enumerate(repos, 1):
            if repo.get('archived', False):
                print(f"\n‚è≠Ô∏è  Pulando reposit√≥rio arquivado: {repo['name']}")
                continue
            
            print(f"\nüìÅ Reposit√≥rio {i}/{len(repos)}: {repo['name']}")
            
            try:
                # FILTRO INTELIGENTE 1: Verificar se reposit√≥rio tem issues em projetos alvo
                print(f"  üîç Verificando se h√° issues em projetos alvo...")
                if not has_relevant_issues(github_token, org, repo['name'], projects_with_field, days_filter):
                    print(f"  ‚è≠Ô∏è  Nenhum issue em projetos alvo encontrado - pulando reposit√≥rio")
                    optimization_stats["repos_skipped_no_relevant_issues"] += 1
                    continue
                
                # Obter issues do reposit√≥rio com filtros otimizados
                print(f"  üì• Buscando issues...")
                issues = get_issues_from_repo(github_token, org, repo['name'], projects_with_field, days_filter)
                print(f"  üìã {len(issues)} issues encontrados")
                optimization_stats["total_issues_found"] += len(issues)
                
                # FILTRO INTELIGENTE 2: Filtrar apenas issues que precisam de altera√ß√£o baseado no Status
                print(f"  üîç Filtrando issues que precisam de altera√ß√£o (Status != Done ou Status = Done sem data)...")
                relevant_issues = filter_issues_that_need_processing(issues, projects_with_field, args.field)
                print(f"  ‚úÖ {len(relevant_issues)} issues precisam de processamento (filtrados {len(issues) - len(relevant_issues)})")
                
                if not relevant_issues:
                    print(f"  ‚è≠Ô∏è  Nenhum issue precisa de altera√ß√£o - pulando processamento")
                    optimization_stats["repos_skipped_no_changes_needed"] += 1
                    continue
                
                optimization_stats["total_issues_processed"] += len(relevant_issues)
                
                # Processar apenas issues relevantes
                for issue in relevant_issues:
                    changes = process_issue_for_projects(
                        github_token, issue, projects_with_field, args.field
                    )
                    
                    # Acumular mudan√ßas
                    for key in total_changes:
                        total_changes[key] += changes[key]
                
                # Pausa entre reposit√≥rios para n√£o sobrecarregar a API
                if i < len(repos):
                    print("  ‚è≥ Aguardando 2 segundos antes do pr√≥ximo reposit√≥rio...")
                    time.sleep(2)
                    
            except Exception as e:
                print(f"‚ùå Erro ao processar reposit√≥rio {repo['name']}: {e}")
                total_changes["errors"] += 1
        
        # Resumo final
        print("\n" + "=" * 60)
        print("üéØ PROCESSAMENTO CONCLU√çDO!")
        print(f"üìä Total de reposit√≥rios processados: {len(repos)}")
        print(f"üìä Total de projetos processados: {len(projects_with_field)}")
        print(f"‚úÖ Campos limpos: {total_changes['cleared']}")
        print(f"üìÖ Campos preenchidos: {total_changes['set']}")
        print(f"‚ùå Erros encontrados: {total_changes['errors']}")
        
        # Estat√≠sticas de otimiza√ß√£o
        print("\n" + "=" * 60)
        print("üöÄ ESTAT√çSTICAS DE OTIMIZA√á√ÉO (Filtros Inteligentes)")
        print(f"üìà Total de issues encontrados: {optimization_stats['total_issues_found']}")
        print(f"‚ö° Issues processados (apenas os que precisavam de altera√ß√£o no Status): {optimization_stats['total_issues_processed']}")
        print(f"‚è≠Ô∏è  Reposit√≥rios pulados (sem issues em projetos alvo): {optimization_stats['repos_skipped_no_relevant_issues']}")
        print(f"‚è≠Ô∏è  Reposit√≥rios pulados (sem altera√ß√µes necess√°rias no Status): {optimization_stats['repos_skipped_no_changes_needed']}")
        
        if optimization_stats['total_issues_found'] > 0:
            efficiency = (optimization_stats['total_issues_processed'] / optimization_stats['total_issues_found']) * 100
            print(f"üéØ Efici√™ncia: {efficiency:.1f}% dos issues processados realmente precisavam de altera√ß√£o")
        
        issues_saved = optimization_stats['total_issues_found'] - optimization_stats['total_issues_processed']
        if issues_saved > 0:
            print(f"üíæ Issues economizados (n√£o processados): {issues_saved}")
        
        if total_changes["errors"] == 0:
            print("üéâ Todas as opera√ß√µes foram conclu√≠das com sucesso!")
        else:
            print("‚ö†Ô∏è  Algumas opera√ß√µes falharam. Verifique os logs acima.")
    
    except KeyboardInterrupt:
        print("\n\n‚èπÔ∏è  Opera√ß√£o interrompida pelo usu√°rio")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Erro inesperado: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()
